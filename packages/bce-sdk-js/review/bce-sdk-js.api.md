## API Report File for "@zhengxs/bce-sdk-js"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { ReadableStream as ReadableStream_2 } from 'node:stream/web';

// @public (undocumented)
export class APIClient {
    constructor({ baseURL, maxRetries, timeout, // 10 minutes
        fetch: overrideFetch, }: APIClientOptions);
    // (undocumented)
    protected authHeaders(_opts: APIClient.RequestOptions, _url: string): APIClient.HeadersInit;
    // (undocumented)
    baseURL: string;
    // (undocumented)
    protected buildRequest<Req extends NonNullable<unknown>>(options: APIClient.RequestOptions<Req>): Promise<{
        req: APIClient.Request;
        url: string;
        timeout: number;
    }>;
    // (undocumented)
    protected buildURL(path: string, query?: Record<string, string>): Promise<string>;
    // (undocumented)
    protected calculateContentLength(body: unknown): string | null;
    // (undocumented)
    protected defaultHeaders(opts: APIClient.RequestOptions, url: string): APIClient.HeadersInit;
    // (undocumented)
    protected defaultQuery(): PromiseOrValue<Record<string, string>>;
    // (undocumented)
    delete<Req extends NonNullable<unknown>, Rsp>(url: string, opts?: PromiseOrValue<APIClient.RequestConfig<Req>>): Promise<Rsp>;
    // (undocumented)
    fetch: APIClient.Fetch;
    // (undocumented)
    fetchWithTimeout(url: RequestInfo, init: APIClient.Request | undefined, ms: number, controller: AbortController): Promise<Response>;
    // (undocumented)
    get<Req extends NonNullable<unknown>, Rsp>(url: string, opts?: PromiseOrValue<APIClient.RequestConfig<Req>>): Promise<Rsp>;
    // (undocumented)
    protected getUserAgent(): string;
    // (undocumented)
    static isMultipartBody: (body: any) => body is MultipartBody;
    // (undocumented)
    protected makeStatusError(status: number | undefined, error: NonNullable<unknown> | undefined, message: string | undefined, headers: Headers | undefined): APIError;
    // (undocumented)
    maxRetries: number;
    // (undocumented)
    static MultipartBody: typeof MultipartBody;
    // (undocumented)
    protected parseResponse<T>(props: APIClient.ResponseProps): Promise<T>;
    // (undocumented)
    patch<Req extends NonNullable<unknown>, Rsp>(url: string, opts?: PromiseOrValue<APIClient.RequestConfig<Req>>): Promise<Rsp>;
    // (undocumented)
    post<Req extends NonNullable<unknown>, Rsp>(url: string, opts?: PromiseOrValue<APIClient.RequestConfig<Req>>): Promise<Rsp>;
    // (undocumented)
    protected prepareRequest(_request: APIClient.Request, _init: {
        url: string;
        options: APIClient.RequestConfig;
    }): PromiseOrValue<void>;
    // (undocumented)
    put<Req extends NonNullable<unknown>, Rsp>(url: string, opts?: PromiseOrValue<APIClient.RequestConfig<Req>>): Promise<Rsp>;
    // (undocumented)
    request<Req extends NonNullable<unknown>, Rsp>(options: PromiseOrValue<APIClient.RequestOptions<Req>>): Promise<Rsp>;
    // (undocumented)
    protected retryRequest(options: APIClient.RequestOptions, retriesRemaining: number, responseHeaders?: Headers | undefined): Promise<APIClient.ResponseProps>;
    // (undocumented)
    protected shouldRetry(response: Response): boolean;
    // (undocumented)
    timeout: number;
    // Warning: (ae-forgotten-export) The symbol "PromiseOrValue" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected validateHeaders(_headers: APIClient.HeadersInit, _customHeaders: APIClient.HeadersInit): PromiseOrValue<void>;
}

// @public (undocumented)
export namespace APIClient {
    // (undocumented)
    export type Fetch = (url: RequestInfo, init?: RequestInit) => Promise<Response>;
    // (undocumented)
    export type HeadersInit = Record<string, string | null | undefined>;
    // (undocumented)
    export type Method = 'get' | 'post' | 'put' | 'patch' | 'delete';
    // (undocumented)
    export type Request = {
        method: Method;
        body?: BodyInit;
        headers: Headers;
        signal?: AbortSignal | null;
    };
    // (undocumented)
    export type RequestConfig<Req extends NonNullable<unknown> = Record<string, unknown>> = {
        method?: Method;
        query?: Record<string, string> | undefined;
        body?: Req | undefined;
        headers?: Record<string, string> | undefined;
        maxRetries?: number;
        stream?: boolean | undefined;
        timeout?: number;
        signal?: AbortSignal | undefined | null;
    };
    // (undocumented)
    export type RequestOptions<Req extends NonNullable<unknown> = Record<string, unknown>> = RequestConfig<Req> & {
        path: string;
        method: Method;
    };
    // (undocumented)
    export type ResponseProps = {
        response: Response;
        options: RequestOptions;
        controller: AbortController;
    };
}

// @public (undocumented)
export interface APIClientOptions {
    baseURL: string;
    defaultHeaders?: HeadersInit;
    fetch?: APIClient.Fetch | undefined;
    maxRetries?: number;
    timeout?: number;
}

// @public (undocumented)
export class APIConnectionError extends APIError {
    constructor({ message, cause }: {
        message?: string;
        cause?: Error | undefined;
    });
    // (undocumented)
    readonly status: undefined;
}

// @public (undocumented)
export class APIConnectionTimeoutError extends APIConnectionError {
    constructor({ message }?: {
        message?: string;
    });
}

// @public (undocumented)
export class APIError extends BCEError {
    constructor(status: number | undefined, error: NonNullable<unknown> | undefined, message: string | undefined, headers: Headers | undefined);
    // (undocumented)
    readonly code: string | null | undefined;
    // (undocumented)
    readonly error: NonNullable<unknown> | undefined;
    // (undocumented)
    static generate(status: number | undefined, errorResponse: NonNullable<unknown> | undefined, message?: string | undefined, headers?: Headers | undefined): APIError;
    // (undocumented)
    readonly headers: Headers | undefined;
    // (undocumented)
    readonly param: string | null | undefined;
    // (undocumented)
    readonly status: number | undefined;
    // (undocumented)
    readonly type: string | undefined;
}

// @public (undocumented)
export class APIUserAbortError extends APIError {
    constructor({ message }?: {
        message?: string;
    });
    // (undocumented)
    readonly status: undefined;
}

// @public (undocumented)
export class AuthenticationError extends APIError {
    // (undocumented)
    readonly status = 401;
}

// @public (undocumented)
export class BadRequestError extends APIError {
    // (undocumented)
    readonly status = 400;
}

// @public (undocumented)
export class BCEClient extends APIClient {
    constructor(options: BCEClientOptions);
    // (undocumented)
    ak: string;
    // (undocumented)
    getAccessToken(): Promise<string>;
    // (undocumented)
    session: SessionCredentials;
    // (undocumented)
    sign(request: SignRequest, options?: SignOptions): string;
    // (undocumented)
    signer: Signer;
    // (undocumented)
    signWithURL(url: string, options?: SignOptions): string;
    // (undocumented)
    sk: string;
}

// @public (undocumented)
export type BCEClientOptions = APIClientOptions & Partial<Credentials>;

// @public (undocumented)
export class BCEError extends Error {
}

// @public (undocumented)
export class BOSClient extends BCEClient {
    constructor(options: BOSClientOptions);
    // (undocumented)
    get host(): string;
    set host(value: string);
    // (undocumented)
    get protocol(): string | undefined;
    set protocol(value: string);
    // (undocumented)
    get region(): string | undefined;
    set region(value: string);
    // (undocumented)
    get service(): string | undefined;
    set service(value: string);
}

// @public (undocumented)
export type BOSClientOptions = Partial<UrlOptions & BCEClientOptions>;

// @public (undocumented)
export class ConflictError extends APIError {
    // (undocumented)
    readonly status = 409;
}

// @public
export interface Credentials {
    ak: string;
    region?: string;
    service?: string;
    sk: string;
}

// @public (undocumented)
export namespace Credentials {
    const // (undocumented)
    ak: string;
    const // (undocumented)
    sk: string;
    const // (undocumented)
    service: string | undefined;
    const // (undocumented)
    region: string;
}

// @public (undocumented)
export class InternalServerError extends APIError {
}

// @public (undocumented)
export const isMultipartBody: (body: any) => body is MultipartBody;

// @public (undocumented)
export class MultipartBody {
    // (undocumented)
    get [Symbol.toStringTag](): string;
    constructor(body: any);
    // (undocumented)
    body: any;
}

// @public (undocumented)
export class NotFoundError extends APIError {
    // (undocumented)
    readonly status = 404;
}

// @public (undocumented)
export class PermissionDeniedError extends APIError {
    // (undocumented)
    readonly status = 403;
}

// @public (undocumented)
export class RateLimitError extends APIError {
    // (undocumented)
    readonly status = 429;
}

// @public (undocumented)
export type RequestOptions = APIClient.RequestOptions;

// @public (undocumented)
export type ServerSentEvent = {
    event: string | null;
    data: string;
    raw: string[];
};

// @public (undocumented)
export class SessionCredentials {
    constructor(credentials?: Credentials);
    // (undocumented)
    protected credentials: Credentials;
    // (undocumented)
    endpoint: string;
    // (undocumented)
    getAccessToken(): Promise<string>;
    // (undocumented)
    getSessionKey(): Promise<string>;
    // Warning: (ae-forgotten-export) The symbol "SessionTokenResponse" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected process(): Promise<SessionTokenResponse>;
    // (undocumented)
    protected request(): Promise<SessionTokenResponse>;
}

// @public (undocumented)
export type SignCredentials = Signer.SignCredentials;

// @public (undocumented)
export class Signer {
    constructor(credentials?: SignCredentials | Credentials);
    // (undocumented)
    protected credentials: SignCredentials | Credentials;
    static headersCanonicalization(headers?: SignRequest['headers'], headersToSign?: string[]): readonly [string, string[]];
    static headersToSign: string[];
    // @internal
    static queryStringCanonicalization(searchParams: SignRequest['query']): string;
    sign(request: SignRequest, options?: SignLegacyOptions): string;
    // (undocumented)
    static signature(signingKey: string, request: SignRequest, options?: SignOptions): string;
    // Warning: (ae-forgotten-export) The symbol "SignLegacyOptions" needs to be exported by the entry point index.d.ts
    signWithURL(url: string, options?: SignLegacyOptions): string;
    // @internal (undocumented)
    static uriCanonicalization(uri: string): string;
    static v1(request: SignRequest, credentials: Credentials, options?: SignLegacyOptions): string;
    static v2(request: SignRequest, credentials: SignCredentials, options?: SignOptions): string;
}

// @public (undocumented)
export namespace Signer {
    // (undocumented)
    export type SignCredentials = Required<Credentials>;
    // (undocumented)
    export interface SignLegacyOptions extends SignOptions {
        expirationInSeconds?: number;
    }
    // (undocumented)
    export interface SignOptions {
        headersToSign?: string[];
        timestamp?: number;
    }
    // (undocumented)
    export type SignRequest = {
        path: string;
        query?: Record<string, string> | URLSearchParams | undefined;
        method?: string;
        headers?: Headers | Record<string, string>;
    };
}

// @public (undocumented)
export type SignOptions = Signer.SignLegacyOptions | Signer.SignOptions;

// @public (undocumented)
export type SignRequest = Signer.SignRequest;

// @public (undocumented)
export class Stream<Item> implements AsyncIterable<Item> {
    // (undocumented)
    [Symbol.asyncIterator](): AsyncIterator<Item>;
    constructor(iterator: () => AsyncIterator<Item>, controller: AbortController);
    // (undocumented)
    controller: AbortController;
    // (undocumented)
    static fromReadableStream<Item>(readableStream: ReadableStream_2, controller: AbortController): Stream<Item>;
    // (undocumented)
    static fromSSEResponse(response: Response, controller: AbortController): Stream<ServerSentEvent>;
    // (undocumented)
    tee(): [Stream<Item>, Stream<Item>];
    // (undocumented)
    toReadableStream(): ReadableStream_2;
}

// @public (undocumented)
export class UnprocessableEntityError extends APIError {
    // (undocumented)
    readonly status = 422;
}

// @public (undocumented)
export type UrlOptions = {
    protocol?: (string & NonNullable<unknown>) | 'https:' | 'http:';
    host: string;
    service?: string;
    region?: string;
};

// @public (undocumented)
export interface WenXinOptions extends Partial<BCEClientOptions> {
}

// @public (undocumented)
export class WenXinWorkshop extends BCEClient {
    constructor(options?: WenXinOptions);
    // Warning: (ae-forgotten-export) The symbol "API" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    chat: API.Chat;
    // (undocumented)
    protected defaultQuery(): Promise<{
        access_token: string;
    }>;
}

// (No @packageDocumentation comment for this package)

```
